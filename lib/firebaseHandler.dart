import 'dart:convert';
import 'dart:io';
import 'dart:isolate';

import 'package:farm_to_dish/global_objects.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:http/http.dart' as http;

import 'Remote/modelstack.dart';
import 'Repository/databaseHelper.dart';
import 'firebase_options.dart';
import 'global_handlers.dart';
import 'global_string.dart';

import 'package:googleapis_auth/auth_io.dart' as auth;
import 'package:googleapis/servicecontrol/v1.dart' as servicecontrol;
//import 'package:googleapis/servicecontrol/v1.dart
//08033500977 Pastor Sam
import 'dart:convert';
import 'package:flutter/services.dart';
import 'dart:developer' as devtools show log;
import 'package:dart_jsonwebtoken/dart_jsonwebtoken.dart';

//import 'notificationcontroller.dart';

// core Flutter primitives
import 'package:flutter/foundation.dart';
// core FlutterFire dependency
import 'package:firebase_core/firebase_core.dart';
// generated by

import 'firebase_options.dart';
// FlutterFire's Firebase Cloud Messaging plugin

import 'package:firebase_messaging/firebase_messaging.dart';

import 'sharedpref.dart';

Future<String> handleUpdates(
    RemoteMessage remoteMessage, bool foreground) async {
  String response = "";
  if (remoteMessage.notification != null) {
    try {
      String msg = jsonEncode(remoteMessage.notification!.body);
      logger("Body:$msg");

      String ttld = jsonEncode(remoteMessage.notification!.title);
      logger("Title:$ttld");

      /*

      Map<String, dynamic> json = jsonDecode(jsonDecode(msg));
      logger("The Title${json['title']}");

      if (json['notify']) {
        NotificationController.createNewNotification(
            json['title'], json['content']);
      }

      */

      Map<String, dynamic> dtt = remoteMessage.data;
      String parse = jsonEncode(dtt);
      logger("The Data: $parse");

      await firebaseProcession(parse);

      // _run(json['content'], json[unq], parse, dtt);
    } catch (e) {
      logger("handler error: $e");
    }
  } else {
    try {
      Map<String, dynamic> dtt = remoteMessage.data;
      String parse = jsonEncode(dtt);
      logger("The Data: $parse");

      await firebaseProcession(parse);
    } catch (e) {
      logger("handler error: $e");
    }
  }

  return response;
}

Future<void> firebaseProcession(String data) async {
  try {
    logger("My Data: $data");
    Map<String, dynamic> dtt = jsonDecode(data);
    logger("Data ess: ${dtt["essence"]}");
    pref = SharedPref();
    switch (dtt["essence"]) {
      case instr:
        break;
      case brdc:
        broadcast bdc =
            broadcast(caption: dtt[cpt], cta: dtt[cta], image: dtt[img]);

        Map<String, String> hd = {cpt: dtt[cpt], cta: dtt[cta], img: dtt[img]};
        pref.setPrefString(cpt, jsonEncode(hd));

        dshCtx.read<UINotifier>().broadCast(bdc);
        break;
      case ord:
        break;
      case acct:
        String bal = dtt[amt];
        try {
          /*
          DatabaseHelper dba = DatabaseHelper(table: usrWlt);

          //   [id, usrId, amt, lstTrnz];
          Map<String, dynamic> item = {
            id: "909891",
            usrId: "909891",
            amt: bal,
            lstTrnz: ""
          };

          

          dba.insertData(item);
          */

          pref.setPrefString(acct, bal);

          balance blh = balance(bal: bal);
          //bll = blh;
          dshCtx.read<UINotifier>().accountBalance(blh);
        } catch (e) {
          logger("$acct Error:  $e");
        }
        break;
    }
  } catch (e) {
    logger("fb procession error: $e");
  }
}

late SharedPref pref;

void _backgroundTask(SendPort sendPort) {
  // Perform time-consuming operation here
  // ...

  // Send result back to the main UI isolate
  sendPort.send('Task completed successfully!');
}

final ReceivePort _port = ReceivePort();

void _startBackgroundTask() async {
  try {
    await Isolate.spawn(_backgroundTask, _port.sendPort);
    _port.listen((message) async {
      logger("got a notification**");

      await Firebase.initializeApp(
        options: DefaultFirebaseOptions.currentPlatform,
      );
    });
  } catch (e) {
    logger("check error: $e");
  }

  try {
    final fcmToken = await FirebaseMessaging.instance.getToken();
    fbId = fcmToken!;
    logger("UserToken:$fbId");
    pref.setPrefString(tk_id, fcmToken);
    pref.setPrefBool(token, true);
  } catch (e) {}

  //  await FirebaseMessaging.instance.getToken();

  //  await Firebase.initializeApp();

  FirebaseMessaging.onMessage.listen((RemoteMessage message) {
    // ignore: avoid_print
    print('Got a message whilst in the foreground!');
    if (message.notification != null) {
      // print('Notification Title: ${message.notification.title}');
      // print('Notification Body: ${message.notification.body}');
    }
  });

  Future<void> messageHandler(RemoteMessage message) async {
    String msg = jsonEncode(message.data);
    logger("Background Message Received:$msg");
    logger("Msg rcpt");
  }

  FirebaseMessaging.onBackgroundMessage(messageHandler);

  FirebaseMessaging.onMessage.listen((event) {
    logger("Fore");
    // do something
  });
  FirebaseMessaging.onMessageOpenedApp.listen((event) {
    logger("Fore OPen");
    // do something
  });

  // FirebaseMessaging.onMessage.listen((RemoteMessage message) {
  //   /*
  //   setState(() {
  //     _messages = [..._messages, message];
  //   });

  //   */
  //   logger("CheckMsg***$message");
  // });
}

Future<void> subscribeToTopic(String topic) async {
  await Firebase.initializeApp();
  await FirebaseMessaging.instance.subscribeToTopic(topic);
}

Future<void> unsubscribeFromTopic(String topic) async {
  await FirebaseMessaging.instance.unsubscribeFromTopic(topic);
}

Future<void> obtainPermissions() async {
  FirebaseMessaging messaging = FirebaseMessaging.instance;

  NotificationSettings settings = await messaging.requestPermission(
    alert: true,
    announcement: false,
    badge: true,
    carPlay: false,
    criticalAlert: false,
    provisional: false,
    sound: true,
  );

  if (settings.authorizationStatus == AuthorizationStatus.authorized) {
    print('User granted permission');
  } else if (settings.authorizationStatus == AuthorizationStatus.provisional) {
    print('User granted provisional permission');
  } else {
    print('User declined or has not accepted permission');
  }
}

/*

Future<void> sendMessageToFcmTopic() throws Exception {
   String topicName = "app_promotion";

   Message message =
       Message.builder()
           .setNotification(
               Notification.builder()
                   .setTitle("A new app is available")
                   .setBody("Check out our latest app in the app store.")
                   .build())
           .setAndroidConfig(
               AndroidConfig.builder()
                   .setNotification(
                       AndroidNotification.builder()
                           .setTitle("A new Android app is available")
                           .setBody("Our latest app is available on Google Play store")
                           .build())
                   .build())
           .setTopic("app_promotion")
           .build();

   FirebaseMessaging.getInstance().send(message);

   System.out.println("Message to topic sent successfully!!");
 }

 */

/*
function createJwtToken($serviceAccountKeyFile) {
    $keyFile = json_decode(file_get_contents($serviceAccountKeyFile), true);
    $privateKey = $keyFile['private_key'];
    $token = [
        "iss" => $keyFile['client_email'],
        "sub" => $keyFile['client_email'],
        "aud" => "https://oauth2.googleapis.com/token",
        "iat" => time(),
        "exp" => time() + 3600,
        "scope" => "https://www.googleapis.com/auth/firebase.messaging",
    ];
    return JWT::encode($token, $privateKey, 'RS256');
}
*/

Future<String> createJwtToken(final serviceAccountKey) async {
  Map<String, dynamic> keyFile = serviceAccountKey;
  //jsonDecode(await rootBundle.loadString('data/auth.json'));
  String privateKey = keyFile['private_key'];

  final today = DateTime.now();
  final OneHourFromNow = today.add(const Duration(hours: 1));

  final jwt = JWT({
    "iss": keyFile['client_email'],
    "sub": keyFile['client_email'],
    "aud": "https://oauth2.googleapis.com/token",
    "iat": DateTime.now,
    "exp": OneHourFromNow,
    "scope": "https://www.googleapis.com/auth/firebase.messaging",
  });

  final pem = serviceAccountKey["private_key"];
  //  final pem = File('./example/rsa_private.pem').readAsStringSync();
  final key = RSAPrivateKey(pem!);

  String token = jwt.sign(key, algorithm: JWTAlgorithm.RS256);

  print('Signed token: $token\n');

  return token;
}

// RSA SHA-256 algorithm
Future<void> rs256(final serviceAccountJson) async {
  String token;

  /* Sign */ {
    // Create a json web token
    final jwt = JWT(
      {
        'id': 123,
        'server': {
          'id': '3e4fc296',
          'loc': 'euw-2',
        }
      },
      issuer: 'https://github.com/jonasroussel/dart_jsonwebtoken',
    );

    // Sign it
    // final pem = await rootBundle.loadString('data/auth.json');
    final pem = serviceAccountJson["private_key"];
    //  final pem = File('./example/rsa_private.pem').readAsStringSync();
    final key = RSAPrivateKey(pem!);

    token = jwt.sign(key, algorithm: JWTAlgorithm.RS256);

    print('Signed token: $token\n');
  }

  /* Verify */ {
    try {
      // Verify a token

      final pem = serviceAccountJson[
          "private_key"]; // await rootBundle.loadString('data/auth.json');

      /// final pem =  File('./example/rsa_public.pem').readAsStringSync();
      final key = RSAPublicKey(pem!);

      final jwt = JWT.verify(token, key);

      print('Payload: ${jwt.payload}');
    } on JWTExpiredException {
      print('jwt expired');
    } on JWTException catch (ex) {
      print(ex.message); // ex: invalid signature
    }
  }
}

Future<String> getAccessToken(Map<String, dynamic> accJson) async {
  List<String> scopes = ["https://www.googleapis.com/auth/firebase.messaging"];

  /*

  http.Client client = await auth.clientViaServiceAccount(
      auth.ServiceAccountCredentials.fromJson(serviceAccountJson), scopes);

  auth.AccessCredentials credentials =
      await auth.obtainAccessCredentialsViaServiceAccount(
          auth.ServiceAccountCredentials.fromJson(serviceAccountJson),
          scopes,
          client);

  client.close();
  return credentials.accessToken.data;
  */

  final client = await auth.clientViaServiceAccount(
      auth.ServiceAccountCredentials.fromJson(accJson), scopes);

  return client.credentials.accessToken.data;
}

Future<void> sendNotification(
    String deviceToken,
    BuildContext context,
    Map<String, dynamic> notification,
    Map<String, dynamic> data,
    Map<String, dynamic> fcmSVToken) async {
  String accessToken = await getAccessToken(fcmSVToken);
  logger("Access $accessToken");

  const String senderId = 'farmtodish-7e3e2';
  String fcmendpoint =
      'https://fcm.googleapis.com/v1/projects/$senderId/messages:send';

  Map<String, dynamic> payload = {
    "message": {
      "token": deviceToken,
      "notification": notification,
      "data": data
    }
  };

  final http.Response response = await http.post(Uri.parse(fcmendpoint),
      headers: <String, String>{
        'Content-Type': 'application/json',
        'Authorization': 'Bearer $accessToken'
      },
      body: jsonEncode(payload));
  if (response.statusCode == 200) {
    print('FCM message sent successfully');
  } else {
    print('Failed to send FCM message: ${response.statusCode}');
  }
}

Future<bool> sendPushMessage({
  required String recipientToken,
  required String title,
  required String body,
}) async {
  final jsonCredentials = await rootBundle.loadString('data/auth.json');
  final creds = auth.ServiceAccountCredentials.fromJson(jsonCredentials);

  final client = await auth.clientViaServiceAccount(
    creds,
    ['https://www.googleapis.com/auth/cloud-platform'],
  );

  final notificationData = {
    'message': {
      'token': recipientToken,
      'notification': {'title': title, 'body': body}
    },
  };

  //https://fcm.googleapis.com/v1/projects/farmtodish-7e3e2/messages:send

  const String senderId = 'farmtodish-7e3e2';
  final response = await client.post(
    Uri.parse('https://fcm.googleapis.com/v1/projects/$senderId/messages:send'),
    headers: {
      'content-type': 'application/json',
    },
    body: jsonEncode(notificationData),
  );

  client.close();
  if (response.statusCode == 200) {
    return true; // Success!
  }

  devtools.log(
      'Notification Sending Error Response status: ${response.statusCode}');
  devtools.log('Notification Response body: ${response.body}');
  return false;
}

/*

Future<void> sendMessageToFcmTopic() throws Exception {
   String topicName = "app_promotion";

   Message message =
       Message.builder()
           .setNotification(
               Notification.builder()
                   .setTitle("A new app is available")
                   .setBody("Check out our latest app in the app store.")
                   .build())
           .setAndroidConfig(
               AndroidConfig.builder()
                   .setNotification(
                       AndroidNotification.builder()
                           .setTitle("A new Android app is available")
                           .setBody("Our latest app is available on Google Play store")
                           .build())
                   .build())
           .setTopic("app_promotion")
           .build();

   FirebaseMessaging.instance.send(message);

   System.out.println("Message to topic sent successfully!!");
 }

 */
